import pandas as pd
import os
from litellm import completion
import openpyxl
import time
import json # 用于解析JSON响应
import sys # 用于退出脚本

# GUI 相关库在需要时才导入，避免在纯命令行环境中引入不必要依赖

# 配置部分
DEFAULT_CONFIG = {
    # AI服务配置
    'AI_SERVICE': 'openai',  # 可选: 'openai' 或 'gemini'
    'MODEL_NAME': 'gpt-4o',
    'OPENAI_API_KEY': '',
    'GEMINI_API_KEY': '',
    
    # 研究配置 (这些可以考虑从用户输入或单独的配置文件读取)
    'RESEARCH_QUESTION': 'Does unhinged (vs. normal) name of an AI agent increase consumers usage intention of the AI agent',
    'CRITERIA': [
        '筛选条件：文献是否shitposting或者unhinged names有关？',
        '筛选条件：文献是否与中文互联网中提到的“这个人/事/物好抽象”的概念有关？',
        # '筛选条件2：文献是否是文献综述',
        # '筛选条件3：文献是否涉及亲社会/亲环境/可持续性消费行为',
    ],

    # 通用细化分析问题配置
    # 用户可以定义任意数量和内容的细化问题
    # 每个问题由一个字典定义，包含:
    #   'prompt_key': 在发送给AI的JSON中使用的键名 (建议使用英文下划线命名法)
    #   'question_text': 向AI提出的具体问题文本 (中文)
    #   'df_column_name': 在输出Excel/CSV中对应的列名 (中文)
    'DETAILED_ANALYSIS_QUESTIONS': [
        {
            'prompt_key': 'connection', # 示例键名
            'question_text': '这篇文章与消费者行为学有关吗', # 示例问题
            'df_column_name': 'connection' # 示例列名
        },
        {
            'prompt_key': 'connection2', # 示例键名
            'question_text': '这篇文章与我关注的研究问题是否有任何的联系？', # 示例问题
            'df_column_name': 'connection2' # 示例列名
        },
        # {
        #     'prompt_key': 'q2_model',
        #     'question_text': '这篇文献理论模型是什么？请用X->M->Y的形式展现，如果有调节变量也请指出。',
        #     'df_column_name': '模型'
        # },
        # {
        #     'prompt_key': 'q3_specific_behavior',
        #     'question_text': '这篇文献中具体关注的消费者的什么行为？',
        #     'df_column_name': '核心消费者行为'
        # },

        # 用户可以根据需要添加更多或修改现有问题
        # 例如，针对特定研究问题："The influence of natural (vs. artificial) sweeteners in food/drink on consumers' purchase intention"
        # 可以这样配置：
        # {
        #     'prompt_key': 'sweetener_type_focus',
        #     'question_text': '这篇文献主要关注哪种类型的甜味剂（天然、人造、两者皆有、未区分）？',
        #     'df_column_name': 'AI_甜味剂类型焦点'
        # },
        # {
        #     'prompt_key': 'purchase_intention_link',
        #     'question_text': '文献是如何将甜味剂与消费者的“购买意愿”联系起来的？',
        #     'df_column_name': 'AI_购买意愿关联方式'
        # },
    ],

    # 数据文件配置
    'INPUT_FILE_PATH': 'C:/Users/91784/Downloads/scopus (8).csv', # 例如: 'data/scopus_export.xlsx'
    'OUTPUT_FILE_SUFFIX': '_analyzed',

    # 其他配置
    'API_REQUEST_DELAY': 1, 
    'TITLE_COLUMN_VARIANTS': ['Title', 'Article Title', '标题', '文献标题'],
    'ABSTRACT_COLUMN_VARIANTS': ['Abstract', '摘要', 'Summary'],
}

def initialize_ai(config):
    service = config['AI_SERVICE']
    model = config['MODEL_NAME']
    if service == 'openai':
        api_key = config.get('OPENAI_API_KEY') or os.getenv('OPENAI_API_KEY')
        if not api_key:
            print("错误：OpenAI API密钥未配置。请在DEFAULT_CONFIG中设置或通过环境变量OPENAI_API_KEY设置。")
            sys.exit(1)
        os.environ['OPENAI_API_KEY'] = api_key
    elif service == 'gemini':
        api_key = config.get('GEMINI_API_KEY') or os.getenv('GEMINI_API_KEY')
        if not api_key:
            print("错误：Gemini API密钥未配置。请在DEFAULT_CONFIG中设置或通过环境变量GEMINI_API_KEY设置。")
            sys.exit(1)
        os.environ['GEMINI_API_KEY'] = api_key
    else:
        print(f"错误：无效的AI服务 '{service}'。必须是 'openai' 或 'gemini'。")
        sys.exit(1)
    print(f"LiteLLM 已使用模型 {model} 初始化 (服务: {service})。")

def get_user_inputs_from_config(config):
    research_question = config['RESEARCH_QUESTION']
    criteria = config['CRITERIA']
    detailed_analysis_questions = config.get('DETAILED_ANALYSIS_QUESTIONS', [])

    if not research_question or research_question == '请在此处定义您的核心研究问题或理论模型。':
        print("错误：研究问题未在CONFIG中定义。")
        sys.exit(1)
    if not criteria or not all(isinstance(c, str) and c for c in criteria): # 检查criteria是否有效
        print("错误：筛选条件列表为空或包含无效条目。请在CONFIG中定义。")
        sys.exit(1)
    if not detailed_analysis_questions: # 检查细化问题是否至少有一个
        print("警告：未在CONFIG中定义细化分析问题 (DETAILED_ANALYSIS_QUESTIONS)。将不会进行细化分析。")
    elif not all(isinstance(q, dict) and 'prompt_key' in q and 'question_text' in q and 'df_column_name' in q for q in detailed_analysis_questions):
        print("错误：DETAILED_ANALYSIS_QUESTIONS 中的一个或多个条目格式不正确。每个条目应为包含 'prompt_key', 'question_text', 'df_column_name' 的字典。")
        sys.exit(1)


    return {
        'research_question': research_question,
        'criteria': criteria,
        'detailed_analysis_questions': detailed_analysis_questions
    }

def get_file_path_from_config(config):
    file_path = config['INPUT_FILE_PATH']
    if not file_path or file_path == 'your_input_file.xlsx':
         print("错误：输入文件路径未在CONFIG中正确配置。")
         sys.exit(1)
    if not os.path.exists(file_path):
        print(f"错误：配置文件中指定的文件路径 '{file_path}' 不存在。")
        sys.exit(1)
    if not (file_path.endswith('.csv') or file_path.endswith('.xlsx')):
        print(f"错误：文件 '{file_path}' 不是支持的CSV或Excel格式。")
        sys.exit(1)
    return file_path

def load_and_validate_data(file_path, config):
    try:
        if file_path.endswith('.csv'):
            df = pd.read_csv(file_path)
        elif file_path.endswith('.xlsx'):
            df = pd.read_excel(file_path)
    except Exception as e:
        print(f"读取文件 '{file_path}' 时出错: {e}")
        sys.exit(1)

    title_column = None
    for col_name_variant in config['TITLE_COLUMN_VARIANTS']:
        if col_name_variant in df.columns:
            title_column = col_name_variant
            break
    abstract_column = None
    for col_name_variant in config['ABSTRACT_COLUMN_VARIANTS']:
        if col_name_variant in df.columns:
            abstract_column = col_name_variant
            break

    if not title_column:
        print(f"警告：无法自动识别标题列。尝试过的名称：{config['TITLE_COLUMN_VARIANTS']}")
        title_column_input = input("请手动输入标题列的准确名称: ").strip()
        if title_column_input not in df.columns:
            print(f"错误：输入的标题列 '{title_column_input}' 不存在于文件中。")
            sys.exit(1)
        title_column = title_column_input
    if not abstract_column:
        print(f"警告：无法自动识别摘要列。尝试过的名称：{config['ABSTRACT_COLUMN_VARIANTS']}")
        abstract_column_input = input("请手动输入摘要列的准确名称: ").strip()
        if abstract_column_input not in df.columns:
            print(f"错误：输入的摘要列 '{abstract_column_input}' 不存在于文件中。")
            sys.exit(1)
        abstract_column = abstract_column_input
    print(f"成功识别列 - 标题: '{title_column}', 摘要: '{abstract_column}'")
    return df, title_column, abstract_column

def prepare_dataframe(df, criteria_list, detailed_analysis_questions_config):
    if detailed_analysis_questions_config:
        for q_config in detailed_analysis_questions_config:
            df[q_config['df_column_name']] = ''
    for criterion_text in criteria_list:
        df[f'筛选_{criterion_text}'] = ''
    return df

def construct_ai_prompt(title, abstract, research_question, screening_criteria, detailed_analysis_questions):
    criteria_prompts_str = ",\n".join([f'        "{criterion}": "请回答 \'是\', \'否\', 或 \'不确定\'"' for criterion in screening_criteria])

    detailed_analysis_prompts_list = []
    if detailed_analysis_questions: # 仅当定义了细化问题时才构建这部分
        for q_config in detailed_analysis_questions:
            detailed_analysis_prompts_list.append(f'        "{q_config["prompt_key"]}": "{q_config["question_text"]}"')
    detailed_analysis_prompts_str = ",\n".join(detailed_analysis_prompts_list)

    # 构建 detailed_analysis 部分，仅当存在细化问题时
    detailed_analysis_section = ""
    if detailed_analysis_prompts_str:
        detailed_analysis_section = f"""
    "detailed_analysis": {{
{detailed_analysis_prompts_str}
    }},""" # 注意这里末尾的逗号，如果 screening_results 存在则需要

    prompt = f"""请仔细阅读以下文献的标题和摘要，并结合给定的理论模型/研究问题进行分析。
请严格按照以下JSON格式返回您的分析结果，所有文本内容请使用中文：

文献标题：{title}
文献摘要：{abstract}

理论模型/研究问题：{research_question}

JSON输出格式要求：
{{
{detailed_analysis_section}
    "screening_results": {{
{criteria_prompts_str}
    }}
}}

重要提示：
1.  对于 "detailed_analysis" 内的每一个子问题（如果存在），请提供简洁、针对性的中文回答。如果摘要中信息不足以回答某个子问题，请注明“摘要未提供相关信息”。
2.  对于 "screening_results" 中的每一个筛选条件，请仅使用 "是"、"否" 或 "不确定" 作为回答。
3.  确保整个输出是一个合法的JSON对象。
"""
    return prompt

def get_ai_response(prompt_text, config, detailed_analysis_questions_config, criteria_config):
    """调用选定的AI服务并获取响应。在出错时返回包含所有预期键的错误JSON。"""
    def _build_error_json(error_message):
        error_da = {}
        if detailed_analysis_questions_config:
            for q_conf in detailed_analysis_questions_config:
                error_da[q_conf['prompt_key']] = error_message
        error_sr = {criterion: error_message for criterion in criteria_config}
        error_dict = {}
        if error_da:
            error_dict["detailed_analysis"] = error_da
        error_dict["screening_results"] = error_sr
        return json.dumps(error_dict)

    try:
        response = completion(
            model=config['MODEL_NAME'],
            messages=[{"role": "user", "content": prompt_text}],
            temperature=0.5,
            response_format={"type": "json_object"}
        )
        return response['choices'][0]['message']['content'].strip()
    except Exception as e:
        print(f"调用AI服务时发生未知错误 ({config['AI_SERVICE']}): {e}")
        return _build_error_json(f"错误：调用AI服务时发生未知错误 - {e}")


def parse_ai_response_json(ai_json_string, criteria_list, detailed_analysis_questions_config):
    """
    解析AI返回的JSON字符串。
    detailed_analysis_questions_config: 配置中定义的细化问题列表。
    """
    # 为所有预期的键设置默认错误/未提供信息的值
    parsed_detailed_analysis = {}
    if detailed_analysis_questions_config:
        for q_config in detailed_analysis_questions_config:
            parsed_detailed_analysis[q_config['prompt_key']] = "AI未提供此项信息或解析失败"
            
    parsed_criteria_answers = {criterion: "AI未提供此项信息或解析失败" for criterion in criteria_list}
    
    final_response_structure = {}
    if detailed_analysis_questions_config: # 仅当配置了细化问题时，最终结构才包含 detailed_analysis
        final_response_structure['detailed_analysis'] = parsed_detailed_analysis
    final_response_structure['screening_results'] = parsed_criteria_answers


    try:
        if not ai_json_string or not isinstance(ai_json_string, str):
            print(f"错误：AI响应为空或格式不正确。")
            # 更新错误信息
            if detailed_analysis_questions_config:
                for q_config in detailed_analysis_questions_config:
                    final_response_structure['detailed_analysis'][q_config['prompt_key']] = "AI响应为空或格式不正确"
            for criterion in criteria_list:
                final_response_structure['screening_results'][criterion] = "AI响应为空或格式不正确"
            return final_response_structure

        data = json.loads(ai_json_string)
        
        # 提取细化分析部分 (如果存在)
        if detailed_analysis_questions_config and "detailed_analysis" in data:
            detailed_analysis_data_from_ai = data.get("detailed_analysis", {})
            for q_config in detailed_analysis_questions_config:
                prompt_k = q_config['prompt_key']
                # 使用 get 获取值，如果键不存在于AI响应中，则保留默认的“未提供信息”
                final_response_structure['detailed_analysis'][prompt_k] = detailed_analysis_data_from_ai.get(prompt_k, parsed_detailed_analysis[prompt_k])
        
        # 提取筛选结果
        screening_results_data_from_ai = data.get("screening_results", {})
        for criterion in criteria_list:
            final_response_structure['screening_results'][criterion] = screening_results_data_from_ai.get(criterion, parsed_criteria_answers[criterion])

        return final_response_structure # 返回包含所有预期键的字典

    except json.JSONDecodeError as e:
        print(f"JSON解析错误: {e}。AI原始响应: '{ai_json_string[:500]}...'")
        if detailed_analysis_questions_config:
            for q_config in detailed_analysis_questions_config:
                final_response_structure['detailed_analysis'][q_config['prompt_key']] = "JSON解析错误"
        for criterion in criteria_list:
            final_response_structure['screening_results'][criterion] = "JSON解析错误"
    except Exception as e:
        print(f"解析AI响应时发生未知错误: {e}")
        if detailed_analysis_questions_config:
            for q_config in detailed_analysis_questions_config:
                final_response_structure['detailed_analysis'][q_config['prompt_key']] = f"解析时发生未知错误"
        for criterion in criteria_list:
            final_response_structure['screening_results'][criterion] = f"解析时发生未知错误"
            
    return final_response_structure

def analyze_article(df, index, row, title_col, abstract_col, research_question, criteria_list, detailed_analysis_questions_config, config):
    title = str(row[title_col]) if pd.notna(row[title_col]) else "无标题"
    abstract = str(row[abstract_col]) if pd.notna(row[abstract_col]) else "无摘要"

    if title == "无标题" and abstract == "无摘要":
        print("警告：文章标题和摘要均缺失，跳过此条目。")
        if detailed_analysis_questions_config:
            for q_config in detailed_analysis_questions_config:
                df.at[index, q_config['df_column_name']] = "标题和摘要均缺失"
        for criterion_text in criteria_list:
            df.at[index, f'筛选_{criterion_text}'] = "无法处理"
        return

    prompt = construct_ai_prompt(title, abstract, research_question, criteria_list, detailed_analysis_questions_config)
    ai_response_json_str = get_ai_response(prompt, config, detailed_analysis_questions_config, criteria_list)
    parsed_data = parse_ai_response_json(ai_response_json_str, criteria_list, detailed_analysis_questions_config)

    if detailed_analysis_questions_config and 'detailed_analysis' in parsed_data:
        da_responses = parsed_data['detailed_analysis']
        for q_config in detailed_analysis_questions_config:
            df.at[index, q_config['df_column_name']] = da_responses.get(q_config['prompt_key'], "信息缺失或键不匹配")

    if 'screening_results' in parsed_data:
        sr_responses = parsed_data['screening_results']
        for criterion_text in criteria_list:
            df.at[index, f'筛选_{criterion_text}'] = sr_responses.get(criterion_text, "信息缺失或键不匹配")
    else:
        for criterion_text in criteria_list:
            df.at[index, f'筛选_{criterion_text}'] = "AI响应严重错误"


# --- 主程序 ---
def main():
    print("--- AI辅助文献分析脚本启动 ---")

    config = DEFAULT_CONFIG

    print("正在初始化AI客户端...")
    initialize_ai(config)

    print("正在获取分析参数...")
    analysis_params = get_user_inputs_from_config(config)
    research_question = analysis_params['research_question']
    criteria_list = analysis_params['criteria']
    detailed_analysis_questions_config = analysis_params.get('detailed_analysis_questions', []) # 这是问题配置的列表

    print("正在加载数据文件...")
    input_file_path = get_file_path_from_config(config)
    df, title_col, abstract_col = load_and_validate_data(input_file_path, config)

    # 准备DataFrame以存储结果
    df = prepare_dataframe(df, criteria_list, detailed_analysis_questions_config)

    total_articles = len(df)
    print(f"共找到 {total_articles} 篇文章待处理。")

    for index, row in df.iterrows():
        print(f"\n正在处理第 {index + 1}/{total_articles} 篇文章...")
        analyze_article(df, index, row, title_col, abstract_col, research_question, criteria_list, detailed_analysis_questions_config, config)
        time.sleep(config['API_REQUEST_DELAY'])

    base, ext = os.path.splitext(input_file_path)
    output_file_path = f"{base}{config['OUTPUT_FILE_SUFFIX']}{ext}"
    
    try:
        if output_file_path.endswith('.csv'):
            df.to_csv(output_file_path, index=False, encoding='utf-8-sig')
        elif output_file_path.endswith('.xlsx'):
            df.to_excel(output_file_path, index=False, engine='openpyxl')
        print(f"\n处理完成！结果已保存到: {output_file_path}")
    except Exception as e:
        print(f"保存结果文件时出错: {e}")

    print("--- 脚本执行完毕 ---")

def run_gui():
    """提供简易图形界面以选择文件并运行分析流程"""
    import threading
    import tkinter as tk
    from tkinter import filedialog, messagebox

    root = tk.Tk()
    root.title("Abstract Screener")

    file_path_var = tk.StringVar()
    status_var = tk.StringVar()

    def browse_file():
        path = filedialog.askopenfilename(filetypes=[("CSV or Excel", ("*.csv", "*.xlsx"))])
        if path:
            file_path_var.set(path)

    def process_file(path):
        config = DEFAULT_CONFIG.copy()
        config['INPUT_FILE_PATH'] = path
        try:
            initialize_ai(config)
            analysis_params = get_user_inputs_from_config(config)
            df, title_col, abstract_col = load_and_validate_data(path, config)
            df = prepare_dataframe(df, analysis_params['criteria'], analysis_params.get('detailed_analysis_questions', []))
            total = len(df)
            for index, row in df.iterrows():
                status_var.set(f"处理中: {index + 1}/{total}")
                analyze_article(df, index, row, title_col, abstract_col,
                                analysis_params['research_question'], analysis_params['criteria'],
                                analysis_params.get('detailed_analysis_questions', []), config)
                time.sleep(config['API_REQUEST_DELAY'])
            base, ext = os.path.splitext(path)
            output_file_path = f"{base}{config['OUTPUT_FILE_SUFFIX']}{ext}"
            if output_file_path.endswith('.csv'):
                df.to_csv(output_file_path, index=False, encoding='utf-8-sig')
            else:
                df.to_excel(output_file_path, index=False, engine='openpyxl')
            messagebox.showinfo("完成", f"处理完成，结果已保存到: {output_file_path}")
        except Exception as e:
            messagebox.showerror("错误", str(e))
        finally:
            status_var.set("")

    def start_analysis():
        path = file_path_var.get()
        if not path:
            messagebox.showerror("错误", "请先选择文件")
            return
        threading.Thread(target=process_file, args=(path,), daemon=True).start()

    tk.Label(root, text="选择CSV/XLSX文件:").pack(pady=5)
    tk.Entry(root, textvariable=file_path_var, width=40).pack(padx=5)
    tk.Button(root, text="浏览", command=browse_file).pack(pady=5)
    tk.Button(root, text="开始分析", command=start_analysis).pack(pady=5)
    tk.Label(root, textvariable=status_var).pack(pady=5)
    root.mainloop()


if __name__ == '__main__':
    if '--gui' in sys.argv:
        run_gui()
    else:
        main()
